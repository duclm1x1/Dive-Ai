from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple

from core.models import Finding
from core.skill_index import SkillDoc, index_skills

_AUTOMAP_FILENAME = "skill_automap.json"
_RULEMAP_FILENAME = "rule_skill_map.json"



def _load_rulemap(repo_root: str) -> Dict[str, List[str]]:
    """
    Load mapping from rule_id patterns to skill_ids.
    Patterns can be exact or use '*' wildcard suffix.
    """
    root = Path(repo_root)
    p = root / ".shared" / "vibe-coder-v13" / "core" / _RULEMAP_FILENAME
    if not p.exists():
        p2 = root / _RULEMAP_FILENAME
        if p2.exists():
            p = p2
    try:
        obj = json.loads(p.read_text(encoding="utf-8"))
        if isinstance(obj, dict):
            out: Dict[str, List[str]] = {}
            for k, v in obj.items():
                if isinstance(v, list):
                    out[str(k)] = [str(x) for x in v if isinstance(x, (str, int, float))]
            return out
    except Exception:
        pass
    return {}


def build_triggers(*, stacks: Sequence[str], findings: Sequence[Finding], gates: Sequence[Dict[str, Any]], task: str = "") -> List[str]:
    """
    Build a compact trigger set used by the router.
    Triggers are intentionally string-based so they can be stable + debuggable.
    """
    trg: List[str] = []

    # stack signals
    for s in stacks or []:
        ss = str(s).strip().lower()
        if ss:
            trg.append(f"stack:{ss}")

    # static findings
    for f in findings or []:
        if getattr(f, "id", None):
            trg.append(f"finding:{str(f.id).strip()}")
        if getattr(f, "rule_id", None):
            trg.append(f"rule:{str(f.rule_id).strip()}")
        if getattr(f, "category", None):
            trg.append(f"category:{str(f.category).strip().lower()}")

    # gate failures
    for g in gates or []:
        name = str(g.get("name") or "gate").strip().lower()
        status = str(g.get("status") or "").strip().lower()
        if status and status != "pass":
            trg.append(f"gate:{name}:{status}")

    # baseline
    trg.append("need:base")

    # Task-intent signals
    t = (task or '').lower()
    if any(k in t for k in ['rlm', 'recursive', 'rag', 'retrieval']):
        trg.append('need:rlm')
        trg.append('need:knowledge')
    if 'n8n' in t or 'workflow' in t:
        trg.append('need:n8n')
    if any(k in t for k in ['test', 'unit test', 'e2e', 'playwright']):
        trg.append('need:testing')
    if any(k in t for k in ['docs', 'documentation', 'readme']):
        trg.append('need:docs')

    # discovery mode (no signals) â€“ helpful when users want inspiration / browsing
    if not (stacks or []) and not (findings or []):
        trg.append("need:discovery")

    # de-dup keep order
    seen = set()
    out: List[str] = []
    for t in trg:
        if t in seen:
            continue
        seen.add(t)
        out.append(t)
    return out


@dataclass
class SkillMapEntry:
    skill_id: str
    rel_path: str
    group_id: str
    kind: str
    tags: List[str]
    base_score: int
    triggers: List[str]
    repo: str = ""


def _load_automap(repo_root: str) -> Dict[str, SkillMapEntry]:
    """
    Automap is generated by the pack (or `vibe skills-reindex`).
    If missing, router falls back to filename heuristics.
    """
    core_dir = Path(__file__).resolve().parent
    p = core_dir / _AUTOMAP_FILENAME
    if not p.exists():
        return {}
    try:
        raw = json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return {}
    out: Dict[str, SkillMapEntry] = {}
    for s in raw.get("skills") or []:
        try:
            e = SkillMapEntry(
                skill_id=str(s.get("skill_id") or ""),
                rel_path=str(s.get("rel_path") or ""),
                group_id=str(s.get("group_id") or (s.get("repo") or s.get("skill_id") or "")),
                kind=str(s.get("kind") or "skillpack"),
                tags=list(s.get("tags") or []),
                base_score=int(s.get("base_score") or 0),
                triggers=list(s.get("triggers") or []),
                repo=str(s.get("repo") or ""),
            )
            if e.skill_id:
                out[e.skill_id] = e
        except Exception:
            continue
    return out


def _heuristic_entry(skill: SkillDoc) -> SkillMapEntry:
    sid = skill.skill_id
    rel = skill.rel_path
    lower = f"{sid} {rel}".lower()
    tags: List[str] = ["agent_runtime"]
    triggers: List[str] = []
    kind = "skillpack"
    base_score = 20
    if sid.startswith("vibe-"):
        base_score = 80
    if sid in {"vibe-super-coder-skills", "vibe-qa-debugging", "vibe-documentation-auto"}:
        base_score = 100

    if "awesome" in lower or "catalog" in lower:
        kind = "registry"
        tags.append("skills_registry")
        triggers.append("need:discovery")

    if "n8n" in lower:
        tags.append("n8n")
        triggers.append("stack:n8n")
    if "next" in lower or "react" in lower:
        tags += ["nextjs", "react"]
        triggers += ["stack:nextjs", "stack:react"]
    if "nest" in lower:
        tags.append("nestjs")
        triggers.append("stack:nestjs")
    if "tailwind" in lower:
        tags.append("tailwind")
        triggers.append("stack:tailwind")
    if "security" in lower or "semgrep" in lower:
        tags.append("security")
        triggers.append("category:security")
    if "test" in lower:
        tags.append("testing")
        triggers.append("category:testing")
    if "docs" in lower or "documentation" in lower:
        tags.append("docs")
        triggers.append("category:docs")

    return SkillMapEntry(
        skill_id=sid,
        rel_path=rel,
        group_id=sid,
        kind=kind,
        tags=sorted(set(tags)),
        base_score=base_score,
        triggers=sorted(set(triggers)),
        repo="",
    )


def route_skills(
    repo_root: str,
    *,
    stacks: Sequence[str],
    findings: Sequence[Finding],
    gates: Sequence[Dict[str, Any]],
    task: str = "",
    enforce_lock: bool = False,
    max_selected: int = 12,
) -> Dict[str, Any]:
    """
    Explainable, automation-first routing.
    - Every skill in the repo gets an automap entry so it can be selected automatically.
    - External skills are excluded if enforce_lock=True and unpinned.
    - Registry/awesome-list skills are only auto-selected in discovery mode.
    - De-dup: do not select multiple skills from the same repo/group_id.
    """
    skills, excluded_external = index_skills(repo_root, enforce_lock=enforce_lock)
    triggers = build_triggers(stacks=stacks, findings=findings, gates=gates, task=task)

    automap = _load_automap(repo_root)
    rulemap = _load_rulemap(repo_root)

    # Build map entries for all skills (so newly-added skills are immediately routable)
    entries: Dict[str, SkillMapEntry] = {}
    for s in skills:
        entries[s.skill_id] = automap.get(s.skill_id) or _heuristic_entry(s)

    # scoring
    def score_entry(e: SkillMapEntry) -> Tuple[int, List[str]]:
        score = int(e.base_score or 0)
        matched: List[str] = []
        trgset = set(triggers)
        for t in e.triggers:
            if t in trgset:
                matched.append(t)
                if t.startswith("stack:"):
                    score += 60
                elif t.startswith("finding:"):
                    score += 50
                elif t.startswith("category:"):
                    score += 35
                elif t.startswith("gate:"):
                    score += 25
                elif t.startswith("need:"):
                    score += 15
                elif t.startswith("kind:"):
                    score += 10

        # Registry skills: only in discovery
        if e.kind == "registry" and "need:discovery" not in trgset:
            score -= 10_000  # practically exclude unless discovery

        return score, matched

    ranked: List[Tuple[int, List[str], SkillMapEntry]] = []
    for e in entries.values():
        sc, matched = score_entry(e)
        ranked.append((sc, matched, e))

    ranked.sort(key=lambda x: x[0], reverse=True)

    # Rule-level mapping: boost skills recommended for matched rule_ids
    if rulemap:
        matched_rules = [t[5:] for t in triggers if t.startswith("rule:")]
        boosts: Dict[str, int] = {}
        for r in matched_rules:
            for pat, skills in rulemap.items():
                if pat.endswith("*"):
                    if r.startswith(pat[:-1]):
                        for sid in skills:
                            boosts[sid] = boosts.get(sid, 0) + 45
                else:
                    if r == pat:
                        for sid in skills:
                            boosts[sid] = boosts.get(sid, 0) + 60

        if boosts:
            boosted: List[Tuple[int, List[str], SkillMapEntry]] = []
            for sc, matched, e in ranked:
                add = boosts.get(e.skill_id, 0)
                if add:
                    matched = list(matched) + [f"rulemap:{r}" for r in matched_rules[:3]]
                boosted.append((sc + add, matched, e))
            ranked = boosted
            ranked.sort(key=lambda x: x[0], reverse=True)


    selected: List[Dict[str, Any]] = []
    used_groups: set[str] = set()

    for sc, matched, e in ranked:
        if len(selected) >= int(max_selected):
            break
        if sc < 0:
            continue
        gid = e.group_id or e.skill_id
        if gid in used_groups:
            continue
        used_groups.add(gid)
        selected.append(
            {
                "skill_id": e.skill_id,
                "rel_path": e.rel_path,
                "score": sc,
                "matched_triggers": matched,
                "kind": e.kind,
                "tags": e.tags,
                "repo": e.repo,
            }
        )

    return {
        'rulemap_loaded': bool(rulemap),
        "selected": selected,
        "all_triggers": triggers,
        "excluded_external_unpinned": excluded_external,
        "enforced_lock": bool(enforce_lock),
        "max_selected": int(max_selected),
        "automap_loaded": bool(automap),
    }
