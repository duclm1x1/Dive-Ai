"""
Autonomous Skill Generator â€” Creates new skill files from natural language specs.
OpenClaw parity: auto-generates and installs new skills on-the-fly.
"""
import os, re, time, json
from typing import Dict, Any, List, Optional
from string import Template

# Base directory for skills
SKILLS_DIR = os.path.dirname(os.path.abspath(__file__))


class SkillGenerator:
    """
    Generates complete skill files from specifications.
    Can create skills from:
    - Natural language description
    - JSON spec
    - Template + logic code
    """

    SKILL_TEMPLATE = Template('''"""
$description
Generated by Dive AI Skill Generator at $timestamp
"""
import os, json, time
from typing import Dict, Any, Optional

import sys
_backend = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
if _backend not in sys.path:
    sys.path.insert(0, _backend)

from dive_core.skills.base_skill import BaseSkill
from dive_core.skills.skill_spec import SkillSpec, SkillCategory
from dive_core.algorithms.base import AlgorithmResult


class $class_name(BaseSkill):
    """$description"""

    def __init__(self):
        super().__init__(SkillSpec(
            name="$skill_name",
            version="1.0.0",
            description="$description",
            category=SkillCategory.$category,
            tags=$tags,
            combo_compatible=True,
        ))

    def _execute(self, inputs: Dict[str, Any],
                 context: Optional[Dict] = None) -> AlgorithmResult:
        """$description"""
        action = inputs.get("action", "$default_action")
        try:
$logic_code
            return AlgorithmResult(
                status="success",
                data=result if isinstance(result, dict) else {"result": result},
                metadata={"skill": "$skill_name", "action": action,
                          "generated": True, "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")},
            )
        except Exception as e:
            return AlgorithmResult(
                status="error",
                data={"error": str(e), "action": action},
            )
''')

    CATEGORY_MAP = {
        "devops": "DEVOPS", "browser": "BROWSER", "search": "SEARCH",
        "communication": "COMMUNICATION", "ai": "AI_ML",
        "productivity": "PRODUCTIVITY", "media": "MEDIA",
        "finance": "FINANCE", "smart_home": "SMART_HOME",
        "coding": "CODING", "utility": "UTILITY", "custom": "CUSTOM",
    }

    def __init__(self):
        self._generated: List[Dict] = []

    def generate(self, name: str, description: str,
                 category: str = "custom",
                 logic_code: str = "",
                 default_action: str = "run",
                 tags: List[str] = None,
                 target_dir: str = None) -> Dict[str, Any]:
        """Generate a complete skill file."""
        # Normalize
        skill_name = name.lower().replace(" ", "_").replace("-", "_")
        class_name = "".join(w.capitalize() for w in skill_name.split("_")) + "Skill"
        cat_enum = self.CATEGORY_MAP.get(category.lower(), "CUSTOM")
        tags = tags or [skill_name, category.lower()]
        
        # Default logic
        if not logic_code:
            logic_code = '            result = {"message": f"Executed {action}", "inputs": inputs}'
        else:
            # Indent logic code to 12 spaces
            lines = logic_code.strip().split("\n")
            logic_code = "\n".join("            " + line for line in lines)

        # Generate code
        code = self.SKILL_TEMPLATE.substitute(
            description=description,
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S"),
            class_name=class_name,
            skill_name=skill_name,
            category=cat_enum,
            tags=str(tags),
            default_action=default_action,
            logic_code=logic_code,
        )

        # Determine target path
        if target_dir is None:
            cat_dir = os.path.join(SKILLS_DIR, category.lower())
        else:
            cat_dir = target_dir
        os.makedirs(cat_dir, exist_ok=True)
        
        file_path = os.path.join(cat_dir, f"{skill_name}_skill.py")

        # Write
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(code)

        # Validate syntax
        try:
            compile(code, file_path, "exec")
            syntax_ok = True
        except SyntaxError as e:
            syntax_ok = False
            return {"success": False, "error": f"Syntax error: {e}", "path": file_path}

        entry = {
            "name": skill_name, "class": class_name,
            "path": file_path, "category": category,
            "created": time.strftime("%Y-%m-%d %H:%M:%S"),
        }
        self._generated.append(entry)

        return {
            "success": True, "path": file_path,
            "name": skill_name, "class": class_name,
            "category": category, "syntax_valid": syntax_ok,
        }

    def generate_from_spec(self, spec: Dict) -> Dict:
        """Generate from a JSON spec dict."""
        return self.generate(
            name=spec["name"],
            description=spec.get("description", ""),
            category=spec.get("category", "custom"),
            logic_code=spec.get("logic_code", ""),
            default_action=spec.get("default_action", "run"),
            tags=spec.get("tags"),
            target_dir=spec.get("target_dir"),
        )

    def batch_generate(self, specs: List[Dict]) -> Dict:
        """Generate multiple skills at once."""
        results = []
        for spec in specs:
            results.append(self.generate_from_spec(spec))
        
        success = sum(1 for r in results if r.get("success"))
        return {
            "total": len(specs), "success": success,
            "failed": len(specs) - success,
            "results": results,
        }

    def list_generated(self) -> List[Dict]:
        """List all generated skills this session."""
        return self._generated

    def get_stats(self) -> Dict:
        return {
            "total_generated": len(self._generated),
            "categories": list(set(g.get("category", "custom") for g in self._generated)),
        }
