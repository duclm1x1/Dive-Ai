"""
Dive AI V29.3 - Self-Evolving Algorithm System
Há»‡ thá»‘ng tá»± Ä‘á»™ng táº¡o má»›i vÃ  tá»‘i Æ°u algorithms

Features:
1. Algorithm Generator - Táº¡o algorithms má»›i tá»« patterns
2. Algorithm Optimizer - Tá»‘i Æ°u algorithms hiá»‡n cÃ³
3. Performance Tracker - Theo dÃµi hiá»‡u suáº¥t
4. Auto-Registration - Tá»± Ä‘á»™ng Ä‘Äƒng kÃ½ algorithms má»›i
"""

import os
import json
import asyncio
from typing import Dict, Any, List, Optional
from datetime import datetime
from dataclasses import dataclass
import ast


@dataclass
class AlgorithmMetrics:
    """Performance metrics for an algorithm"""
    name: str
    total_executions: int = 0
    successful_executions: int = 0
    failed_executions: int = 0
    avg_execution_time_ms: float = 0
    success_rate: float = 0
    last_optimized: Optional[str] = None
    optimization_count: int = 0


class AlgorithmGenerator:
    """
    Automatically generates new algorithms based on:
    - User needs
    - Performance gaps
    - Common patterns
    """
    
    def __init__(self, algorithm_manager, llm_provider="v98"):
        self.algorithm_manager = algorithm_manager
        self.llm_provider = llm_provider
        
        # Generated algorithms directory
        self.generated_dir = "core/algorithms/generated"
        os.makedirs(self.generated_dir, exist_ok=True)
        
        print("ðŸ§¬ Algorithm Generator initialized")
    
    async def generate_algorithm(
        self,
        need: str,
        examples: List[Dict[str, Any]] = None
    ) -> Optional[str]:
        """
        Generate a new algorithm based on identified need
        
        Args:
            need: Description of what algorithm should do
            examples: Example inputs/outputs
        
        Returns:
            Generated algorithm name or None
        """
        
        print(f"\nðŸ§¬ Generating new algorithm for: {need}")
        
        # 1. Get LLM connection
        connection = self.algorithm_manager.get_connection(provider=self.llm_provider)
        if connection.status != "success":
            print(f"âŒ LLM connection failed")
            return None
        
        # 2. Build generation prompt
        prompt = self._build_generation_prompt(need, examples)
        
        # 3. Generate algorithm code (simulated for now)
        # In production, would call LLM API
        algorithm_code = self._generate_code(need)
        
        # 4. Save to file
        algorithm_name = self._extract_name_from_need(need)
        file_path = os.path.join(self.generated_dir, f"{algorithm_name.lower()}.py")
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(algorithm_code)
        
        print(f"âœ… Generated algorithm: {algorithm_name}")
        print(f"   Saved to: {file_path}")
        
        # 5. Auto-register
        try:
            self._register_generated_algorithm(file_path, algorithm_name)
            print(f"âœ… Auto-registered: {algorithm_name}")
        except Exception as e:
            print(f"âš ï¸ Auto-registration failed: {e}")
        
        return algorithm_name
    
    def _build_generation_prompt(self, need: str, examples: List[Dict[str, Any]]) -> str:
        """Build prompt for algorithm generation"""
        
        examples_text = ""
        if examples:
            examples_text = "\n\nEXAMPLES:\n"
            for i, ex in enumerate(examples, 1):
                examples_text += f"\nExample {i}:\n"
                examples_text += f"Input: {json.dumps(ex.get('input', {}), indent=2)}\n"
                examples_text += f"Output: {json.dumps(ex.get('output', {}), indent=2)}\n"
        
        prompt = f"""Generate a Dive AI algorithm for the following need:

NEED: {need}
{examples_text}

REQUIREMENTS:
1. Must inherit from BaseAlgorithm
2. Must have AlgorithmSpec with proper IO definitions
3. Must implement execute(params) method
4. Should handle errors gracefully
5. Should return AlgorithmResult

Generate complete Python code following Dive AI V29.2 algorithm patterns.
"""
        return prompt
    
    def _generate_code(self, need: str) -> str:
        """Generate algorithm code (template for now)"""
        
        algorithm_name = self._extract_name_from_need(need)
        class_name = f"{algorithm_name}Algorithm"
        
        code = f'''"""
Auto-generated Algorithm: {algorithm_name}
Generated: {datetime.now().isoformat()}
Purpose: {need}
"""

from core.algorithms.base_algorithm import BaseAlgorithm, AlgorithmResult
from core.algorithms.algorithm_spec import AlgorithmSpec, AlgorithmIOSpec, IOField


class {class_name}(BaseAlgorithm):
    """
    {need}
    
    Auto-generated by Algorithm Generator
    """
    
    def __init__(self):
        self.spec = AlgorithmSpec(
            algorithm_id="{algorithm_name}",
            name="{algorithm_name}",
            level="operational",
            category="generated",
            version="1.0",
            description="{need}",
            
            io=AlgorithmIOSpec(
                inputs=[
                    IOField("input_data", "any", True, "Input data for processing")
                ],
                outputs=[
                    IOField("output_data", "any", True, "Processed output")
                ]
            ),
            
            steps=[],
            tags=["auto-generated"]
        )
    
    def execute(self, params: dict) -> AlgorithmResult:
        """Execute the algorithm"""
        
        input_data = params.get('input_data')
        
        try:
            # TODO: Implement actual logic
            # This is a template - needs refinement
            output_data = self._process(input_data)
            
            return AlgorithmResult(
                status="success",
                data={{"output_data": output_data}}
            )
            
        except Exception as e:
            return AlgorithmResult(
                status="error",
                data={{"error": str(e)}}
            )
    
    def _process(self, input_data):
        """Processing logic - to be implemented"""
        # Placeholder: echo input
        return input_data
'''
        return code
    
    def _extract_name_from_need(self, need: str) -> str:
        """Extract algorithm name from need description"""
        # Simple name extraction
        words = need.split()[:3]  # Take first 3 words
        name = ''.join(word.capitalize() for word in words if word.isalnum())
        return name or "GeneratedAlgorithm"
    
    def _register_generated_algorithm(self, file_path: str, algorithm_name: str):
        """Dynamically import and register generated algorithm"""
        
        # Import module dynamically
        import importlib.util
        spec = importlib.util.spec_from_file_location(algorithm_name, file_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # Find algorithm class
        class_name = f"{algorithm_name}Algorithm"
        if hasattr(module, class_name):
            algorithm_class = getattr(module, class_name)
            algorithm_instance = algorithm_class()
            
            # Register with AlgorithmManager
            self.algorithm_manager.register(algorithm_name, algorithm_instance)
        else:
            raise Exception(f"Class {class_name} not found in generated module")


class AlgorithmOptimizer:
    """
    Automatically optimizes existing algorithms based on:
    - Performance metrics
    - Error patterns
    - Usage patterns
    """
    
    def __init__(self, algorithm_manager, llm_provider="v98"):
        self.algorithm_manager = algorithm_manager
        self.llm_provider = llm_provider
        
        # Metrics tracking
        self.metrics: Dict[str, AlgorithmMetrics] = {}
        
        # Optimization history
        self.optimization_history: List[Dict[str, Any]] = []
        
        print("âš¡ Algorithm Optimizer initialized")
    
    def track_execution(
        self,
        algorithm_name: str,
        success: bool,
        execution_time_ms: float
    ):
        """Track algorithm execution for optimization"""
        
        if algorithm_name not in self.metrics:
            self.metrics[algorithm_name] = AlgorithmMetrics(name=algorithm_name)
        
        metrics = self.metrics[algorithm_name]
        metrics.total_executions += 1
        
        if success:
            metrics.successful_executions += 1
        else:
            metrics.failed_executions += 1
        
        # Update average execution time
        current_avg = metrics.avg_execution_time_ms
        total = metrics.total_executions
        metrics.avg_execution_time_ms = (
            (current_avg * (total - 1)) + execution_time_ms
        ) / total
        
        # Update success rate
        metrics.success_rate = metrics.successful_executions / metrics.total_executions
    
    async def optimize_algorithm(self, algorithm_name: str) -> bool:
        """
        Optimize a specific algorithm
        
        Returns:
            True if optimization successful
        """
        
        if algorithm_name not in self.metrics:
            print(f"âš ï¸ No metrics for {algorithm_name}, cannot optimize")
            return False
        
        metrics = self.metrics[algorithm_name]
        
        print(f"\nâš¡ Optimizing algorithm: {algorithm_name}")
        print(f"   Current Success Rate: {metrics.success_rate*100:.1f}%")
        print(f"   Avg Execution Time: {metrics.avg_execution_time_ms:.2f}ms")
        
        # Analyze for optimization opportunities
        optimizations = self._identify_optimizations(metrics)
        
        if not optimizations:
            print(f"   âœ… Algorithm already optimal")
            return True
        
        # Apply optimizations
        for optimization in optimizations:
            print(f"   ðŸ”§ Applying: {optimization['type']}")
            await self._apply_optimization(algorithm_name, optimization)
        
        # Update metrics
        metrics.last_optimized = datetime.now().isoformat()
        metrics.optimization_count += 1
        
        # Record history
        self.optimization_history.append({
            'algorithm': algorithm_name,
            'timestamp': datetime.now().isoformat(),
            'optimizations': optimizations,
            'metrics_before': {
                'success_rate': metrics.success_rate,
                'avg_time_ms': metrics.avg_execution_time_ms
            }
        })
        
        print(f"   âœ… Optimization complete")
        return True
    
    def _identify_optimizations(self, metrics: AlgorithmMetrics) -> List[Dict[str, Any]]:
        """Identify optimization opportunities"""
        
        optimizations = []
        
        # Low success rate
        if metrics.success_rate < 0.8:
            optimizations.append({
                'type': 'error_handling',
                'reason': f'Low success rate: {metrics.success_rate*100:.1f}%',
                'priority': 'high'
            })
        
        # High execution time
        if metrics.avg_execution_time_ms > 1000:
            optimizations.append({
                'type': 'performance',
                'reason': f'High execution time: {metrics.avg_execution_time_ms:.2f}ms',
                'priority': 'medium'
            })
        
        # Many executions without optimization
        if metrics.total_executions > 100 and metrics.optimization_count == 0:
            optimizations.append({
                'type': 'pattern_learning',
                'reason': f'{metrics.total_executions} executions without optimization',
                'priority': 'low'
            })
        
        return optimizations
    
    async def _apply_optimization(self, algorithm_name: str, optimization: Dict[str, Any]):
        """Apply specific optimization"""
        
        opt_type = optimization['type']
        
        if opt_type == 'error_handling':
            # Add better error handling
            print(f"      â†’ Adding enhanced error handling")
            # In production: modify algorithm code to add try-catch, validation, etc.
        
        elif opt_type == 'performance':
            # Add caching, optimize logic
            print(f"      â†’ Optimizing performance (caching, async, etc.)")
            # In production: add memoization, async execution, etc.
        
        elif opt_type == 'pattern_learning':
            # Learn from execution patterns
            print(f"      â†’ Learning from execution patterns")
            # In production: analyze common inputs, optimize for them
    
    def get_optimization_report(self) -> Dict[str, Any]:
        """Get optimization report"""
        
        return {
            'total_algorithms_tracked': len(self.metrics),
            'total_optimizations': len(self.optimization_history),
            'algorithms': [
                {
                    'name': name,
                    'executions': m.total_executions,
                    'success_rate': f"{m.success_rate*100:.1f}%",
                    'avg_time_ms': f"{m.avg_execution_time_ms:.2f}",
                    'optimizations': m.optimization_count,
                    'last_optimized': m.last_optimized or 'Never'
                }
                for name, m in self.metrics.items()
            ],
            'recent_optimizations': self.optimization_history[-5:]
        }


class SelfEvolvingSystem:
    """
    Complete self-evolving algorithm system
    Combines generation and optimization
    """
    
    def __init__(self, algorithm_manager):
        self.algorithm_manager = algorithm_manager
        
        # Components
        self.generator = AlgorithmGenerator(algorithm_manager)
        self.optimizer = AlgorithmOptimizer(algorithm_manager)
        
        # Auto-optimization settings
        self.auto_optimize_threshold = 50  # Optimize after N executions
        self.auto_optimize_enabled = True
        
        print("ðŸŒŸ Self-Evolving Algorithm System initialized")
    
    async def evolve(self):
        """
        Main evolution loop
        - Generate new algorithms for gaps
        - Optimize existing algorithms
        """
        
        print("\nðŸŒŸ Starting evolution cycle...")
        
        # 1. Identify needs (gaps in capabilities)
        needs = self._identify_needs()
        
        # 2. Generate new algorithms for needs
        for need in needs:
            await self.generator.generate_algorithm(need)
        
        # 3. Optimize existing algorithms
        for algo_name, metrics in self.optimizer.metrics.items():
            if metrics.total_executions >= self.auto_optimize_threshold:
                await self.optimizer.optimize_algorithm(algo_name)
        
        print("âœ… Evolution cycle complete")
    
    def _identify_needs(self) -> List[str]:
        """Identify gaps in algorithm capabilities"""
        
        # Analyze:
        # - Failed requests (no suitable algorithm)
        # - Low-performing algorithms
        # - Emerging patterns
        
        needs = []
        
        # Example needs (in production, would analyze actual usage)
        # needs.append("Image processing with AI vision")
        # needs.append("Advanced data analysis and visualization")
        
        return needs
    
    def get_status(self) -> Dict[str, Any]:
        """Get evolution system status"""
        
        return {
            'generator': {
                'generated_algorithms': len([
                    f for f in os.listdir(self.generator.generated_dir)
                    if f.endswith('.py')
                ]) if os.path.exists(self.generator.generated_dir) else 0
            },
            'optimizer': self.optimizer.get_optimization_report(),
            'auto_optimize_enabled': self.auto_optimize_enabled,
            'auto_optimize_threshold': self.auto_optimize_threshold
        }


# Test function
async def test_self_evolving_system():
    """Test the self-evolving system"""
    
    print("\nðŸ§ª Testing Self-Evolving Algorithm System\n")
    
    # Mock AlgorithmManager
    class MockAlgorithmManager:
        def __init__(self):
            self.algorithms = {}
        
        def register(self, name, algorithm):
            self.algorithms[name] = algorithm
            print(f"   Registered: {name}")
        
        def get_connection(self, provider):
            return type('obj', (object,), {'status': 'success'})()
    
    # Create system
    manager = MockAlgorithmManager()
    system = SelfEvolvingSystem(manager)
    
    # Test algorithm generation
    print("="*60)
    print("TEST: Algorithm Generation")
    print("="*60)
    await system.generator.generate_algorithm(
        need="Process user feedback and extract sentiment"
    )
    
    # Test optimization tracking
    print("\n" + "="*60)
    print("TEST: Algorithm Optimization")
    print("="*60)
    
    # Simulate executions
    for i in range(60):
        system.optimizer.track_execution(
            algorithm_name="TestAlgorithm",
            success=i % 10 != 0,  # 90% success rate
            execution_time_ms=100 + (i % 20)
        )
    
    # Optimize
    await system.optimizer.optimize_algorithm("TestAlgorithm")
    
    # Get status
    print("\n" + "="*60)
    print("SYSTEM STATUS")
    print("="*60)
    status = system.get_status()
    print(json.dumps(status, indent=2))


if __name__ == "__main__":
    asyncio.run(test_self_evolving_system())
